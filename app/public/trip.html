<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Trip Details - Trippino</title>
    <link rel="icon" type="image/png" href="favicon.png" />
    <script src="https://unpkg.com/maplibre-gl@5.12.0/dist/maplibre-gl.js"></script>
    <link
      href="https://unpkg.com/maplibre-gl@5.12.0/dist/maplibre-gl.css"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg: #f6f8fa;
        --card: #ffffff;
        --muted: #8a5a32;
        --primary: #f97316;
        --accent: #ffb380;
      }

      body {
        font-family:
          Inter,
          system-ui,
          -apple-system,
          "Segoe UI",
          Roboto,
          "Helvetica Neue",
          Arial;
        background: var(--bg);
        margin: 0;
        padding: 10px;
        color: #111;
      }

      .app {
        max-width: 980px;
        margin: 0 auto;
      }

      header {
        display: flex;
        gap: 12px;
        align-items: center;
        margin-bottom: 18px;
      }

      h1 {
        font-size: 20px;
        margin: 0;
      }

      /* Top navigation shared styles */
      .topnav {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 18px;
      }

      .topnav .brand {
        font-size: 20px;
        font-weight: 700;
        color: inherit;
        text-decoration: none;
      }

      .menu-item:hover {
        background: #f6f6f6;
        border-radius: 6px;
      }

      input[type="text"],
      input[type="number"] {
        padding: 8px 10px;
        border: 1px solid #ddd;
        border-radius: 6px;
      }

      .card {
        background: var(--card);
        padding: 14px;
        border-radius: 12px;
        box-shadow: 0 6px 18px rgba(12, 18, 32, 0.06);
        margin-bottom: 12px;
      }

      .cities {
        margin-top: 12px;
      }

      .city {
        display: grid;
        grid-template-columns: 24px 1fr 160px 250px 80px;
        gap: 8px;
        align-items: center;
        padding: 8px;
        border-radius: 8px;
        border: 1px dashed #eee;
        margin-bottom: 6px;
        cursor: default;
      }

      .city.active {
        background: #f6f8fa;
      }

      .city .expand-arrow {
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #999;
        transition: transform 0.2s ease;
        cursor: pointer;
      }

      .city .expand-arrow:hover {
        color: var(--primary);
      }

      .city .expand-arrow svg {
        width: 16px;
        height: 16px;
      }

      .city.active .expand-arrow {
        transform: rotate(90deg);
      }

      .city .notes {
        display: none;
      }

      .city.active .notes {
        display: block;
      }

      .city-edit-actions {
        display: none;
        grid-column: 1 / -1;
        gap: 8px;
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid #eee;
      }

      .city.active .city-edit-actions {
        display: flex;
      }

      .city-edit-actions button {
        flex: 1;
        padding: 10px;
        border: 1px solid #ddd;
        background: white;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
      }

      .city-edit-actions button:hover {
        background: #f0f0f0;
      }

      .city-reorder-controls {
        display: none;
        grid-column: 1 / -1;
        gap: 8px;
        margin-top: 8px;
      }

      .city.active .city-reorder-controls {
        display: flex;
      }

      .city-reorder-controls button {
        flex: 1;
        padding: 10px;
        border: 1px solid #ddd;
        background: white;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
      }

      .city-reorder-controls button:active {
        background: #f0f0f0;
      }

      .city-reorder-controls button:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      .city .name {
        font-weight: 600;
        margin: 0;
      }

      .calendar-wrapper {
        margin-top: 12px;
      }

      .map-wrapper {
        margin-top: 12px;
      }

      #tripMap {
        height: 400px;
        border-radius: 8px;
        z-index: 1;
        position: relative;
      }

      .map-loading {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: var(--bg);
        border-radius: 8px;
        z-index: 10;
      }

      .map-loading .spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #ddd;
        border-top-color: var(--primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      .map-loading .loading-text {
        margin-top: 12px;
        color: var(--muted);
        font-size: 14px;
      }

      .map-error {
        padding: 40px 20px;
        text-align: center;
        color: var(--muted);
      }

      /* MapLibre marker styles */
      .city-marker {
        background: var(--primary);
        color: white;
        border-radius: 50%;
        width: 22px;
        height: 22px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        font-size: 14px;
        border: 2px solid white;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        cursor: pointer;
      }

      .stepover-marker {
        background: #f97316;
        color: white;
        border-radius: 50%;
        width: 12px;
        height: 12px;
        border: 2px solid white;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        cursor: pointer;
      }

      .maplibregl-popup-content {
        padding: 8px 12px;
        border-radius: 6px;
      }

      .maplibregl-popup-anchor-bottom .maplibregl-popup-tip,
      .maplibregl-popup-anchor-top .maplibregl-popup-tip {
        border-top-color: var(--primary);
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .months {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(230px, 1fr));
        gap: 12px;
        width: 100%;
        box-sizing: border-box;
      }

      .month-card {
        border-radius: 8px;
        border: 1px solid #eee;
        padding: 10px;
        background: var(--card);
        box-sizing: border-box;
        width: 100%;
      }

      .month-header {
        font-weight: 700;
        margin-bottom: 6px;
      }

      .weekday-row {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        font-size: 12px;
        color: var(--muted);
        text-align: center;
      }

      .days-grid {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 0;
      }

      .day {
        height: 56px;
        border-radius: 0;
        background: #fff;
        text-align: right;
        padding: 6px;
        font-size: 13px;
        position: relative;
        box-sizing: border-box;
        overflow: visible;
      }

      .day.blank {
        background: transparent;
      }

      .day.in-range {
        color: inherit;
      }

      .day.range-start {
        border-top-left-radius: 20px;
        border-bottom-left-radius: 20px;
      }

      .day.range-end {
        border-top-right-radius: 20px;
        border-bottom-right-radius: 20px;
      }

      .range-seg {
        position: absolute;
        left: 0px;
        right: -2px;
        height: 14px;
        background: var(--primary);
        color: #fff;
        font-size: 12px;
        line-height: 14px;
        padding: 0 6px;
        box-sizing: border-box;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        display: flex;
        align-items: center;
        gap: 6px;
        border-radius: 0;
        z-index: 1;
      }

      .range-seg .seg-label {
        font-size: 11px;
        color: #fff;
      }

      .day .date-num {
        z-index: 2;
      }

      .range-seg.range-start {
        border-top-left-radius: 10px;
        border-bottom-left-radius: 10px;
      }

      .range-seg.range-end {
        border-top-right-radius: 10px;
        border-bottom-right-radius: 10px;
      }

      .day .date-num {
        position: absolute;
        right: 6px;
        top: 6px;
        font-size: 12px;
        color: inherit;
      }

      .small {
        font-size: 12px;
        color: var(--muted);
      }

      .nights-control {
        display: flex;
        gap: 6px;
        align-items: center;
      }

      .nights-control button {
        width: 30px;
        height: 30px;
        border: none;
        cursor: pointer;
        background: #fff;
        border-radius: 20px;
        transition: background-color 0.2s;
      }

      .nights-control button:hover {
        background: #f0f0f0;
      }

      .meta {
        font-size: 13px;
        color: var(--muted);
      }

      .topline {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .btn {
        padding: 8px 10px;
        border-radius: 8px;
        border: 0;
        cursor: pointer;
      }

      .btn.primary {
        background: var(--primary);
        color: white;
      }

      .btn.ghost {
        background: transparent;
        border: 1px solid #ddd;
      }

      @media (max-width: 720px) {
        body {
          overflow-x: hidden;
        }

        .topline {
          flex-direction: column;
          align-items: flex-start;
          gap: 10px;
        }

        .topline > div {
          flex-wrap: wrap;
          width: 100%;
        }

        .topline input[type="text"],
        .topline input[type="date"] {
          width: 100%;
          box-sizing: border-box;
        }

        .city {
          position: relative;
          display: grid;
          grid-template-columns: 24px minmax(120px, 1fr) auto auto;
          grid-template-rows: auto auto;
          gap: 0px;
          padding: 5px;
          cursor: default;
          align-items: center;
        }

        .city .date-range,
        .city .stepover,
        .city .no-start {
          grid-column: 2 / -1;
          grid-row: 2;
          margin-top: 0;
          font-size: 12px;
        }

        .city-edit-actions button {
          padding: 6px 8px;
          min-width: 36px;
          height: 36px;
          border-radius: 6px;
        }

        .card {
          margin: 4px 0;
          padding: 12px;
        }
      }

      footer {
        margin-top: 48px;
        padding: 24px 0;
        border-top: 1px solid #e5e7eb;
        text-align: center;
        color: var(--muted);
        font-size: 14px;
      }

      footer a {
        color: var(--primary);
        text-decoration: none;
      }

      footer a:hover {
        text-decoration: underline;
      }

      .footer-links {
        display: flex;
        justify-content: center;
        gap: 16px;
        margin-bottom: 8px;
        flex-wrap: wrap;
      }
    </style>
  </head>

  <body>
    <div class="app">
      <header class="topnav">
        <a href="index.html" class="brand">Trippino</a>
        <div
          style="
            margin-left: auto;
            display: flex;
            gap: 8px;
            align-items: center;
          "
        >
          <div id="authArea"></div>
          <div id="burgerWrapper" style="position: relative; margin-left: 8px">
            <button id="burgerBtn" aria-label="Open menu" class="btn ghost">
              â˜°
            </button>
            <div
              id="burgerMenu"
              style="
                display: none;
                position: absolute;
                right: 0;
                top: 40px;
                background: var(--card);
                border: 1px solid #eee;
                border-radius: 8px;
                box-shadow: 0 6px 18px rgba(12, 18, 32, 0.06);
                z-index: 1000;
                min-width: 160px;
                padding: 6px;
              "
            >
              <div
                class="small menu-item"
                data-action="home"
                style="padding: 8px; cursor: pointer"
              >
                Home
              </div>
              <div
                class="small menu-item"
                data-action="profile"
                style="padding: 8px; cursor: pointer"
              >
                Profile
              </div>
              <div
                class="small menu-item"
                data-action="about"
                style="padding: 8px; cursor: pointer"
              >
                About
              </div>
              <div
                class="small menu-item"
                data-action="logout"
                style="padding: 8px; cursor: pointer"
              >
                Logout
              </div>
            </div>
          </div>
        </div>
      </header>

      <!-- Anonymous user banner (hidden when authenticated or no local trips) -->
      <div
        id="anonBanner"
        style="
          display: none;
          margin-bottom: 12px;
          padding: 10px;
          border-radius: 8px;
          background: var(--accent);
          color: #4a2a12;
        "
      >
        <strong>Unsaved changes</strong> â€” Your trips are only stored locally on
        this device.
        <a
          href="auth.html"
          style="
            font-weight: 700;
            color: var(--primary);
            text-decoration: underline;
            margin-left: 8px;
          "
          >Create an account or login to persist your data</a
        >
      </div>

      <div id="tripContainer"></div>
    </div>

    <script src="/config.js"></script>
    <script type="module">
      import { getCsrfToken } from "/modules/csrf.js";
      import { getCurrentUser, logout } from "/modules/auth.js";
      // --- Service Worker registration ---
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker
          .register("/sw.js")
          .then((reg) => console.log("Service Worker registered:", reg.scope))
          .catch((err) =>
            console.error("Service Worker registration failed:", err),
          );
      }

      const API_BASE = window.APP_CONFIG.API_BASE;
      const TOMTOM_API_KEY = window.APP_CONFIG.TOMTOM_API_KEY;
      const STORAGE_KEY = "simpleTripPlanner_v1";
      const MAX_CITIES_PER_TRIP = 30;
      const MAX_CITY_NAME_LENGTH = 60;
      const MAX_NIGHTS_PER_CITY = 365;
      const NAME_SAFE_REGEX = /^[A-Za-z0-9 \-\'\(\)\.,]*$/;
      const TRANSPORT_MODES = [
        { value: "flight", label: "Flight", icon: "âœˆ" },
        { value: "car", label: "Car", icon: "ðŸš—" },
        { value: "public_transport", label: "Public transport", icon: "ðŸšŒ" },
        { value: "train", label: "Train", icon: "ðŸš†" },
        { value: "boat", label: "Boat", icon: "â›´" },
        { value: "bike", label: "Bike", icon: "ðŸš²" },
        { value: "motorbike", label: "Motorbike", icon: "ðŸï¸" },
        { value: "walk", label: "Walk", icon: "ðŸš¶" },
      ];

      // --- Auth config & helpers ---
      const authArea = document.getElementById("authArea");
      const anonBanner = document.getElementById("anonBanner");
      // currentUser: null = anonymous, otherwise object with email
      let currentUser = null;

      async function checkAuth() {
        try {
          const user = await getCurrentUser();
          if (!user) {
            setAnonymous();
            return null;
          }
          setAuthenticated(user);
          return user;
        } catch (e) {
          console.warn("auth check failed", e);
          setAnonymous();
          return null;
        }
      }
      // Kick off initial auth check
      checkAuth();

      function setAuthenticated(user) {
        currentUser = user;
        authArea.innerHTML = "";
        // show burger button when authenticated
        const burgerBtn = document.getElementById("burgerBtn");
        if (burgerBtn) burgerBtn.style.display = "";
        updateAnonBanner();

        // attach menu handlers
        const menu = document.getElementById("burgerMenu");
        if (menu) {
          menu.querySelectorAll(".menu-item").forEach((mi) => {
            mi.addEventListener("click", async (ev) => {
              const act = mi.dataset.action;
              if (act === "logout") {
                await doLogout();
                window.location.href = "index.html";
              } else if (act === "profile") {
                window.location.href = "profile.html";
              } else if (act === "about") {
                window.location.href = "about.html";
              } else if (act === "home") {
                window.location.href = "index.html";
              }
              menu.style.display = "none";
            });
          });
        }
      }

      function updateAnonBanner() {
        try {
          // show banner only when anonymous and there are local trips
          const hasLocalTrips =
            appState &&
            Array.isArray(appState.trips) &&
            appState.trips.length > 0;
          if (!currentUser && hasLocalTrips) {
            anonBanner.style.display = "";
          } else {
            anonBanner.style.display = "none";
          }
        } catch (e) {
          // ignore
        }
      }

      function setAnonymous() {
        currentUser = null;
        authArea.innerHTML = `
                <button id="goAuthBtn" class="btn primary">Sign in / Register</button>
            `;
        document.getElementById("goAuthBtn").addEventListener("click", () => {
          // open the dedicated auth page
          window.location.href = "auth.html";
        });
        updateAnonBanner();
      }

      async function doLogout() {
        try {
          await logout();
        } catch (e) {
          console.warn("logout failed", e);
        }
        checkAuth();
        localStorage.clear();
        appState = { trips: [] };
        render();
      }

      // Get trip ID from URL
      const urlParams = new URLSearchParams(window.location.search);
      const tripId = Number(urlParams.get("id"));

      if (!tripId) {
        window.location.href = "index.html";
      }

      const uid = () => Math.random().toString(36).slice(2, 9);

      function load() {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return { trips: [] };
        try {
          return JSON.parse(raw);
        } catch (e) {
          console.warn("load failed", e);
          return { trips: [] };
        }
      }

      function save(appState) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(appState));
      }

      async function saveApi(appState) {
        try {
          const token = await getCsrfToken();
          await fetch(`${API_BASE}/api/state`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "CSRF-Token": token,
            },
            credentials: "include",
            body: JSON.stringify({ state: appState }),
          });
        } catch (e) {
          console.warn("push local to backend failed", e);
        }
      }

      let appState = load();
      if (!appState.trips) appState.trips = [];

      const trip = appState.trips.find((t) => t.id === tripId);
      if (!trip) {
        alert("Trip not found");
        window.location.href = "index.html";
      }

      if (!Array.isArray(trip.transportation)) {
        trip.transportation = [];
      }

      ensureCitiesSorted(trip);

      function ensureCitiesSorted(targetTrip = trip) {
        if (!targetTrip || !Array.isArray(targetTrip.cities)) return;
        targetTrip.cities.forEach((city, index) => {
          const numericOrder = Number(city.sort_order);
          city.sort_order = Number.isFinite(numericOrder)
            ? numericOrder
            : index;
        });
        targetTrip.cities.sort((a, b) => a.sort_order - b.sort_order);
      }

      function reindexCitySortOrders(cities = trip?.cities) {
        if (!Array.isArray(cities)) return;
        cities.forEach((city, index) => {
          city.sort_order = index;
        });
      }

      function validateCityName(name) {
        if (!name || !name.trim())
          return { ok: false, error: "City name required" };
        if (name.length > MAX_CITY_NAME_LENGTH)
          return {
            ok: false,
            error: `City name too long (max ${MAX_CITY_NAME_LENGTH} characters)`,
          };
        if (!NAME_SAFE_REGEX.test(name))
          return { ok: false, error: "City name contains invalid characters" };
        return { ok: true };
      }

      function validateNights(n) {
        const v = Number(n) || 0;
        if (!Number.isFinite(v) || v < 0)
          return { ok: false, error: "Nights must be a non-negative number" };
        if (v > MAX_NIGHTS_PER_CITY)
          return {
            ok: false,
            error: `Nights per city cannot exceed ${MAX_NIGHTS_PER_CITY}`,
          };
        return { ok: true };
      }

      function showClientError(msg) {
        try {
          alert(msg);
        } catch (e) {
          console.error(msg);
        }
      }

      // Server-first city update helper. Accepts partial fields: { name?, nights?, notes?, latitude?, longitude? }.
      async function updateCity(cityId, changes) {
        console.log("Updating city with changes:", changes);
        const c = trip.cities.find(
          (x) => x.id === cityId || x.id === Number(cityId),
        );
        if (!c) return false;

        // Validate fields client-side when provided
        if (typeof changes.name !== "undefined") {
          const v = validateCityName(String(changes.name));
          if (!v.ok) {
            showClientError(v.error);
            return false;
          }
        }
        if (typeof changes.nights !== "undefined") {
          const v = validateNights(changes.nights);
          if (!v.ok) {
            showClientError(v.error);
            return false;
          }
        }

        // Anonymous users: update locally only
        if (!currentUser) {
          if (typeof changes.name !== "undefined")
            c.name = String(changes.name);
          if (typeof changes.nights !== "undefined")
            c.nights = Math.max(0, Number(changes.nights));
          if (typeof changes.notes !== "undefined")
            c.notes = String(changes.notes || "");
          if (typeof changes.latitude !== "undefined")
            c.latitude = changes.latitude;
          if (typeof changes.longitude !== "undefined")
            c.longitude = changes.longitude;
          updateTripInStore();
          render();
          return true;
        }

        // Authenticated: call backend first
        const prev = {
          name: c.name,
          nights: Number(c.nights),
          notes: c.notes,
          latitude: c.latitude,
          longitude: c.longitude,
        };
        try {
          const token = await getCsrfToken();
          const payload = {};
          if (typeof changes.name !== "undefined")
            payload.name = String(changes.name);
          if (typeof changes.nights !== "undefined")
            payload.nights = Math.max(0, Number(changes.nights));
          if (typeof changes.notes !== "undefined")
            payload.notes = String(changes.notes || "");
          if (typeof changes.latitude !== "undefined")
            payload.latitude = changes.latitude;
          if (typeof changes.longitude !== "undefined")
            payload.longitude = changes.longitude;

          if (Object.keys(payload).length === 0) return false;

          const res = await fetch(
            `${API_BASE}/api/trips/${trip.id}/cities/${c.id}`,
            {
              method: "PUT",
              headers: {
                "Content-Type": "application/json",
                "CSRF-Token": token,
              },
              credentials: "include",
              body: JSON.stringify(payload),
            },
          );

          if (res.ok) {
            const data = await res.json().catch(() => ({}));
            const uc = data && data.city ? data.city : null;
            if (uc) {
              c.name = uc.name;
              c.nights = Number(uc.nights);
              c.notes = uc.notes || "";
              c.latitude = uc.latitude || null;
              c.longitude = uc.longitude || null;
            } else {
              if (typeof changes.name !== "undefined")
                c.name = String(changes.name);
              if (typeof changes.nights !== "undefined")
                c.nights = Math.max(0, Number(changes.nights));
              if (typeof changes.notes !== "undefined")
                c.notes = String(changes.notes || "");
              if (typeof changes.latitude !== "undefined")
                c.latitude = changes.latitude;
              if (typeof changes.longitude !== "undefined")
                c.longitude = changes.longitude;
            }
            updateTripInStore();
            render();
            return true;
          } else if (res.status === 401) {
            currentUser = null;
            checkAuth();
            showClientError("Session expired. Please sign in again.");
          } else if (res.status === 400) {
            const err = await res.json().catch(() => ({}));
            showClientError(err.error || "Invalid city update.");
          } else if (res.status === 404) {
            const err = await res.json().catch(() => ({}));
            showClientError(
              err.error ||
                "City not found or you don't have permission to edit it.",
            );
          } else {
            const err = await res.json().catch(() => ({}));
            console.warn("Failed to update city in backend:", err);
            showClientError(
              "Cannot update city: backend error (read-only mode).",
            );
          }
        } catch (e) {
          console.warn("Network error updating city:", e);
          showClientError(
            "Cannot update city: offline or network error (read-only mode).",
          );
        }

        // Revert local changes if any accidental UI edits happened
        c.name = prev.name;
        c.nights = prev.nights;
        c.notes = prev.notes;
        c.latitude = prev.latitude;
        c.longitude = prev.longitude;
        render();
        return false;
      }

      function findTransportationForLeg(fromCityId, toCityId) {
        if (!Array.isArray(trip.transportation)) return null;
        return (
          trip.transportation.find(
            (t) =>
              (t.from_city_id === fromCityId ||
                t.from_city_id === Number(fromCityId)) &&
              (t.to_city_id === toCityId || t.to_city_id === Number(toCityId)),
          ) || null
        );
      }

      function upsertTransportationLocal(fromCityId, toCityId, mode, notes) {
        if (!Array.isArray(trip.transportation)) trip.transportation = [];
        const existing = findTransportationForLeg(fromCityId, toCityId);
        if (existing) {
          existing.mode = mode;
          existing.notes = notes || "";
        } else {
          trip.transportation.push({
            id: uid(),
            trip_id: trip.id,
            from_city_id: fromCityId,
            to_city_id: toCityId,
            mode,
            notes: notes || "",
          });
        }
        updateTripInStore();
        render();
      }

      function removeTransportationLocal(fromCityId, toCityId) {
        if (!Array.isArray(trip.transportation)) return;
        trip.transportation = trip.transportation.filter(
          (t) =>
            !(
              (t.from_city_id === fromCityId ||
                t.from_city_id === Number(fromCityId)) &&
              (t.to_city_id === toCityId || t.to_city_id === Number(toCityId))
            ),
        );
        updateTripInStore();
        render();
      }

      async function updateNights(cityId, newNights) {
        // Delegate to updateCity with server-first pattern
        return await updateCity(cityId, {
          nights: Math.max(0, Number(newNights)),
        });
      }

      function removeCityFromTrip(cityId) {
        // If user is logged in, try to delete from backend first
        if (currentUser) {
          (async () => {
            try {
              const token = await getCsrfToken();
              const deleteRes = await fetch(
                `${API_BASE}/api/trips/${trip.id}/cities/${cityId}`,
                {
                  method: "DELETE",
                  headers: {
                    "CSRF-Token": token,
                  },
                  credentials: "include",
                },
              );

              if (deleteRes.ok) {
                // Successfully deleted from backend, now delete from local
                trip.cities = trip.cities.filter((c) => c.id !== cityId);
                reindexCitySortOrders(trip.cities);

                // Update sort order in backend for remaining cities
                try {
                  const updateRes = await fetch(
                    `${API_BASE}/api/trips/${trip.id}/cities`,
                    {
                      method: "PUT",
                      headers: {
                        "Content-Type": "application/json",
                        "CSRF-Token": token,
                      },
                      credentials: "include",
                      body: JSON.stringify({
                        sortOrder: trip.cities.map((c, index) => ({
                          id: c.id,
                          index: index,
                        })),
                      }),
                    },
                  );

                  if (!updateRes.ok) {
                    console.warn(
                      "Failed to update sort order after delete, but city was deleted",
                    );
                  }
                } catch (e) {
                  console.warn("Failed to update sort order after delete:", e);
                }

                updateTripInStore();
                render();
              } else if (deleteRes.status === 401) {
                // Session expired
                console.warn("Session expired");
                currentUser = null;
                checkAuth();
                return showClientError(
                  "Session expired. Please sign in again.",
                );
              } else if (deleteRes.status === 400) {
                // Validation error from backend
                const err = await deleteRes.json().catch(() => ({}));
                console.warn("Validation error deleting city:", err);
                return showClientError(err.error || "Invalid city ID.");
              } else if (deleteRes.status === 404) {
                // City not found or unauthorized
                const err = await deleteRes.json().catch(() => ({}));
                console.warn("City not found or unauthorized:", err);
                return showClientError(
                  err.error ||
                    "City not found or you don't have permission to delete it.",
                );
              } else {
                // Other backend error - read-only mode
                const err = await deleteRes.json().catch(() => ({}));
                console.warn("Failed to delete city from backend:", err);
                return showClientError(
                  "Cannot delete city: backend error (read-only mode).",
                );
              }
            } catch (e) {
              // Network error or offline - read-only mode
              console.warn(
                "Failed to delete city from backend (network error):",
                e,
              );
              return showClientError(
                "Cannot delete city: offline or network error (read-only mode).",
              );
            }
          })();
        } else {
          // Anonymous user - delete locally only
          trip.cities = trip.cities.filter((c) => c.id !== cityId);
          reindexCitySortOrders(trip.cities);
          updateTripInStore();
          render();
        }
      }

      function updateTripInStore() {
        const idx = appState.trips.findIndex((x) => x.id === trip.id);
        if (idx === -1) return;
        appState.trips[idx] = trip;
        save(appState);
      }

      function addDays(d, n) {
        const t = new Date(d);
        t.setDate(t.getDate() + n);
        return t;
      }

      function formatDate(d) {
        return d.toISOString().slice(0, 10);
      }

      function weekdayName(d) {
        return ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][d.getDay()];
      }

      function escapeHtml(s) {
        return String(s).replace(/[&<>"']/g, function (ch) {
          return {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;",
          }[ch];
        });
      }

      // Typeahead styles
      const styleEl = document.createElement("style");
      styleEl.textContent = `
            .tt-popup { position: absolute; background: white; border: 1px solid #eee; box-shadow: 0 6px 18px rgba(12,18,32,0.06); border-radius:6px; z-index:1000; width:260px; }
            .tt-popup .tt-item { padding:8px; cursor:pointer; border-bottom:1px solid #f2f4f6 }
            .tt-popup .tt-item:last-child { border-bottom:0 }
            .tt-popup .tt-item:hover { background:#f6f8fa }
            .tt-input-inline { padding:6px 8px; border:1px solid #ddd; border-radius:6px; width:220px }
        `;
      document.head.appendChild(styleEl);

      function createCitySearchPopup(anchorEl, onSelect, initialValue = "") {
        const popup = document.createElement("div");
        popup.className = "tt-popup";
        popup.style.minWidth = "260px";
        popup.style.padding = "8px";

        const input = document.createElement("input");
        input.className = "tt-input-inline";
        input.value = initialValue || "";
        popup.appendChild(input);

        const list = document.createElement("div");
        list.style.maxHeight = "260px";
        list.style.overflow = "auto";
        list.style.marginTop = "6px";
        popup.appendChild(list);

        document.body.appendChild(popup);
        const rect = anchorEl.getBoundingClientRect();
        popup.style.position = "absolute";
        popup.style.left = `${rect.left}px`;
        popup.style.top = `${rect.bottom + window.scrollY + 6}px`;

        let debounceTimer = null;

        async function doQuery(q) {
          if (!q) {
            renderList([]);
            return;
          }
          try {
            const limit = 6;
            const url = `https://api.tomtom.com/search/2/search/${encodeURIComponent(q)}.json?key=${TOMTOM_API_KEY}&limit=${limit}&typeahead=true&entityTypeSet=Municipality`;
            const res = await fetch(url);
            if (!res.ok) {
              renderList([]);
              return;
            }
            const json = await res.json();
            const suggestions = (json.results || []).map((r) => ({
              name: `${r.address.freeformAddress}, ${r.address.countryCode || ""}`.trim(),
              position: r.position
                ? {
                    latitude: r.position.lat,
                    longitude: r.position.lon,
                  }
                : null,
            }));
            renderList(suggestions);
          } catch (e) {
            console.warn("TomTom proxy query failed", e);
            renderList([]);
          }
        }

        function renderList(items) {
          list.innerHTML = "";
          if (!items.length) {
            const none = document.createElement("div");
            none.className = "tt-item";
            none.textContent = "No suggestions";
            list.appendChild(none);
            return;
          }
          for (const it of items) {
            const el = document.createElement("div");
            el.className = "tt-item";
            el.textContent = it.name || "Unknown";
            el.addEventListener("click", () => {
              cleanup();
              onSelect(it);
            });
            list.appendChild(el);
          }
        }

        function cleanup() {
          if (debounceTimer) clearTimeout(debounceTimer);
          if (popup && popup.parentNode) popup.parentNode.removeChild(popup);
          document.removeEventListener("mousedown", docMouse);
        }

        function docMouse(e) {
          if (!popup.contains(e.target) && !anchorEl.contains(e.target)) {
            cleanup();
            onSelect(null);
          }
        }

        input.addEventListener("input", (ev) => {
          const q = ev.target.value.trim();
          if (debounceTimer) clearTimeout(debounceTimer);
          debounceTimer = setTimeout(() => doQuery(q), 300);
        });

        input.addEventListener("keydown", (ev) => {
          if (ev.key === "Enter") {
            const first = list.querySelector(".tt-item");
            if (first) first.click();
          } else if (ev.key === "Escape") {
            cleanup();
            onSelect(null);
          }
        });

        document.addEventListener("mousedown", docMouse);

        if (input.value && input.value.length >= 2) {
          doQuery(input.value);
        }

        input.focus();
        return popup;
      }

      function render() {
        const container = document.getElementById("tripContainer");
        container.innerHTML = "";

        // fetch info from state
        const trip = appState.trips.find((t) => t.id === tripId);
        if (!trip) return;
        ensureCitiesSorted(trip);

        // Trip editor card
        const editorCard = document.createElement("div");
        editorCard.className = "card";

        const topline = document.createElement("div");
        topline.className = "topline";
        topline.innerHTML = `
                <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
                    <h2 style="margin:0;font-size:18px">${trip.name || "Unnamed trip"}</h2>
                    <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
                        <div class="small" style="color:var(--muted)">Start date</div>
                        <input class="trip-start" type="date" value="${trip.start_date || ""}" />
                    </div>
                </div>
            `;
        editorCard.appendChild(topline);

        const citiesContainer = document.createElement("div");
        citiesContainer.className = "cities";
        editorCard.appendChild(citiesContainer);

        const metaRow = document.createElement("div");
        metaRow.style.display = "flex";
        metaRow.style.justifyContent = "space-between";
        metaRow.style.alignItems = "center";
        metaRow.style.marginTop = "12px";
        metaRow.innerHTML = `<div class="meta">Total nights: <span class="total-nights">0</span></div>`;
        editorCard.appendChild(metaRow);

        const startInput = topline.querySelector(".trip-start");
        startInput.addEventListener("change", async () => {
          const prev = trip.start_date || "";
          const newVal = startInput.value || "";
          // If logged in, attempt backend update first
          if (currentUser) {
            try {
              const token = await getCsrfToken();
              const res = await fetch(`${API_BASE}/api/trips/${trip.id}`, {
                method: "PUT",
                headers: {
                  "Content-Type": "application/json",
                  "CSRF-Token": token,
                },
                credentials: "include",
                body: JSON.stringify({ start_date: newVal || null }),
              });
              if (res.ok) {
                const data = await res.json().catch(() => ({}));
                trip.start_date =
                  (data && data.trip && data.trip.start_date) || newVal;
                updateTripInStore();
                render();
              } else if (res.status === 401) {
                currentUser = null;
                checkAuth();
                showClientError("Session expired. Please sign in again.");
                startInput.value = prev;
              } else if (res.status === 400) {
                const err = await res.json().catch(() => ({}));
                showClientError(err.error || "Invalid start date.");
                startInput.value = prev;
              } else if (res.status === 404) {
                const err = await res.json().catch(() => ({}));
                showClientError(
                  err.error ||
                    "Trip not found or you don't have permission to edit it.",
                );
                startInput.value = prev;
              } else {
                const err = await res.json().catch(() => ({}));
                console.warn("Failed to update start date in backend:", err);
                showClientError(
                  "Cannot update trip: backend error (read-only mode).",
                );
                startInput.value = prev;
              }
            } catch (e) {
              console.warn("Network error updating start date:", e);
              showClientError(
                "Cannot update trip: offline or network error (read-only mode).",
              );
              startInput.value = prev;
            }
          } else {
            // Anonymous: update locally
            trip.start_date = newVal;
            updateTripInStore();
            render();
          }
        });

        renderCitiesList(citiesContainer);

        const total = trip.cities.reduce((s, c) => s + Number(c.nights), 0);
        const totalNightsEl = editorCard.querySelector(".total-nights");
        if (totalNightsEl) totalNightsEl.textContent = total;

        container.appendChild(editorCard);

        // Calendar card
        const calCard = document.createElement("div");
        calCard.className = "card calendar-wrapper";
        renderTripCalendar(calCard);
        container.appendChild(calCard);

        // Map card
        const mapCard = document.createElement("div");
        mapCard.className = "card map-wrapper";
        mapCard.innerHTML = `
                <h3 style="margin:0 0 8px 0">Route map</h3>
                <div id="tripMap">
                    <div class="map-loading">
                        <div class="spinner"></div>
                        <div class="loading-text">Loading map...</div>
                    </div>
                </div>
            `;
        container.appendChild(mapCard);

        // Render map after DOM is ready
        setTimeout(() => renderTripMap(), 100);
      }

      function renderCitiesList(citiesContainer) {
        ensureCitiesSorted(trip);
        // Auto-resize textarea function
        function autoResizeTextarea(textarea) {
          textarea.style.height = "auto";
          const newHeight = Math.min(textarea.scrollHeight, 300); // Max 300px
          textarea.style.height = Math.max(newHeight, 72) + "px"; // Min 72px
        }

        citiesContainer.innerHTML = "";
        let dayCursor = 1;

        for (let i = 0; i < trip.cities.length; i++) {
          const c = trip.cities[i];
          const start = dayCursor;
          const end = dayCursor + Number(c.nights);
          const cityRow = document.createElement("div");
          cityRow.className = "city";
          cityRow.dataset.id = c.id;

          let dateHtml = "";
          if (!trip.start_date) {
            dateHtml =
              '<div class="small no-start" style="color:var(--muted)">No start date</div>';
          } else if (Number(c.nights) === 0) {
            dateHtml =
              '<div class="small stepover" style="font-weight:600;color:var(--muted)">Stepover</div>';
          } else {
            dateHtml = `<div class="small date-range">${formatDate(addDays(new Date(trip.start_date), start - 1))} (${weekdayName(addDays(new Date(trip.start_date), start - 1))}) â†’ ${formatDate(addDays(new Date(trip.start_date), end - 1))} (${weekdayName(addDays(new Date(trip.start_date), end - 1))})</div>`;
          }

          cityRow.innerHTML = `
                    <div class="expand-arrow" role="button" aria-label="Expand city">
                        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M9 6l6 6-6 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </div>
                    <div>
                        <div class="name">
                            ${c.name || "Unnamed city"}
                        </div>
                    </div>
                    <div class="nights-control">
                        <button data-action="dec">âˆ’</button>
                        <div class="nights-display" style="background:white;width:30px;text-align:center;padding:1px 1px;border: none;border-radius:6px">${c.nights}</div>
                        <button data-action="inc">+</button>
                    </div>
                    ${dateHtml}
                    <div class="city-edit-actions">
                        <button data-action="rename" class="btn ghost" title="Rename">âœŽ Rename</button>
                        <button data-action="remove" class="btn ghost" title="Remove city" aria-label="Remove city">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true">
                                <path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                            Delete
                        </button>
                    </div>
                    <div class="city-reorder-controls">
                        <button data-action="move-up">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M18 15l-6-6-6 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                            Move Up
                        </button>
                        <button data-action="move-down">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M6 9l6 6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                            Move Down
                        </button>
                    </div>
                    <div class="notes" style="grid-column:1 / -1;margin-top:8px">
                      <textarea class="city-notes" placeholder="Notes about this city..." style="width:100%;min-height:72px;max-height:300px;border:1px solid #eee;padding:8px;border-radius:8px;box-sizing:border-box;resize:none;overflow-y:auto">${escapeHtml(c.notes || "")}</textarea>
                      <div style="text-align:right;margin-top:6px">
                        <button data-action="save-note" class="btn primary">Save note</button>
                      </div>
                    </div>
                    <div class="transport-edit" style="display:none;grid-column:1 / -1;margin-top:8px">
                      <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
                        <span style="font-size:13px;color:#555">Transportation to next city</span>
                        <select class="transport-mode" style="padding:6px 8px;border-radius:6px;border:1px solid #ddd;font-size:13px">
                          <option value="">Select mode...</option>
                          ${TRANSPORT_MODES.map((m) => `<option value="${m.value}">${m.icon} ${m.label}</option>`).join("")}
                        </select>
                        <input type="text" class="transport-notes" placeholder="Details (optional)" style="flex:1;min-width:140px;padding:6px 8px;border-radius:6px;border:1px solid #ddd;font-size:13px" />
                        <button class="btn ghost" data-action="save-transport" style="font-size:13px;padding:6px 10px">Save</button>
                        <button class="btn ghost" data-action="remove-transport" style="font-size:13px;padding:6px 10px">Remove</button>
                      </div>
                      <div class="transport-hint" style="margin-top:4px;font-size:12px;color:#888"></div>
                    </div>
                `;

          cityRow
            .querySelector('[data-action="dec"]')
            .addEventListener("click", async (e) => {
              e.stopPropagation();
              const newNights = Math.max(0, Number(c.nights) - 1);
              await updateNights(c.id, newNights);
            });

          cityRow
            .querySelector('[data-action="inc"]')
            .addEventListener("click", async (e) => {
              e.stopPropagation();
              const newNights = Math.max(0, Number(c.nights) + 1);
              await updateNights(c.id, newNights);
            });

          cityRow
            .querySelector('[data-action="remove"]')
            .addEventListener("click", (e) => {
              e.stopPropagation();
              removeCityFromTrip(c.id);
            });

          cityRow
            .querySelector('[data-action="rename"]')
            .addEventListener("click", (ev) => {
              ev.stopPropagation();
              const renameBtn = ev.currentTarget;
              createCitySearchPopup(
                renameBtn,
                async (sel) => {
                  if (!sel) return;
                  const name = (sel.name || "").trim();
                  const vname = validateCityName(name);
                  if (!vname.ok) return showClientError(vname.error);

                  // Prepare update data
                  const updateData = { name };
                  if (
                    sel.position &&
                    sel.position.latitude &&
                    sel.position.longitude
                  ) {
                    updateData.latitude = sel.position.latitude;
                    updateData.longitude = sel.position.longitude;
                  }

                  // Server-first update for name and coordinates
                  await updateCity(c.id, updateData);
                },
                c.name,
              );
            });

          // Move up/down buttons
          const moveUpBtn = cityRow.querySelector('[data-action="move-up"]');
          const moveDownBtn = cityRow.querySelector(
            '[data-action="move-down"]',
          );

          // Disable buttons if at the edges
          if (i === 0) moveUpBtn.disabled = true;
          if (i === trip.cities.length - 1) moveDownBtn.disabled = true;

          moveUpBtn.addEventListener("click", async (e) => {
            e.stopPropagation();
            if (i === 0) return;

            // Prepare new order without mutating yet
            const newOrder = trip.cities.slice();
            const temp = newOrder[i];
            newOrder[i] = newOrder[i - 1];
            newOrder[i - 1] = temp;

            if (currentUser) {
              try {
                const token = await getCsrfToken();
                const res = await fetch(
                  `${API_BASE}/api/trips/${trip.id}/cities`,
                  {
                    method: "PUT",
                    headers: {
                      "Content-Type": "application/json",
                      "CSRF-Token": token,
                    },
                    credentials: "include",
                    body: JSON.stringify({
                      sortOrder: newOrder.map((c, index) => ({
                        id: c.id,
                        index,
                      })),
                    }),
                  },
                );
                if (res.ok) {
                  trip.cities = newOrder;
                  reindexCitySortOrders(trip.cities);
                  updateTripInStore();
                  render();
                } else if (res.status === 401) {
                  currentUser = null;
                  checkAuth();
                  showClientError("Session expired. Please sign in again.");
                } else if (res.status === 400) {
                  const err = await res.json().catch(() => ({}));
                  showClientError(err.error || "Invalid sort order update.");
                } else if (res.status === 404) {
                  const err = await res.json().catch(() => ({}));
                  showClientError(
                    err.error || "City or trip not found/unauthorized.",
                  );
                } else {
                  const err = await res.json().catch(() => ({}));
                  console.warn("Failed to reorder cities:", err);
                  showClientError(
                    "Cannot reorder: backend error (read-only mode).",
                  );
                }
              } catch (err) {
                console.warn("Network error reordering cities:", err);
                showClientError(
                  "Cannot reorder: offline or network error (read-only mode).",
                );
              }
            } else {
              // Anonymous: apply locally
              trip.cities = newOrder;
              reindexCitySortOrders(trip.cities);
              updateTripInStore();
              render();
            }
          });

          moveDownBtn.addEventListener("click", async (e) => {
            e.stopPropagation();
            if (i === trip.cities.length - 1) return;

            const newOrder = trip.cities.slice();
            const temp = newOrder[i];
            newOrder[i] = newOrder[i + 1];
            newOrder[i + 1] = temp;

            if (currentUser) {
              try {
                const token = await getCsrfToken();
                const res = await fetch(
                  `${API_BASE}/api/trips/${trip.id}/cities`,
                  {
                    method: "PUT",
                    headers: {
                      "Content-Type": "application/json",
                      "CSRF-Token": token,
                    },
                    credentials: "include",
                    body: JSON.stringify({
                      sortOrder: newOrder.map((c, index) => ({
                        id: c.id,
                        index,
                      })),
                    }),
                  },
                );
                if (res.ok) {
                  trip.cities = newOrder;
                  reindexCitySortOrders(trip.cities);
                  updateTripInStore();
                  render();
                } else if (res.status === 401) {
                  currentUser = null;
                  checkAuth();
                  showClientError("Session expired. Please sign in again.");
                } else if (res.status === 400) {
                  const err = await res.json().catch(() => ({}));
                  showClientError(err.error || "Invalid sort order update.");
                } else if (res.status === 404) {
                  const err = await res.json().catch(() => ({}));
                  showClientError(
                    err.error || "City or trip not found/unauthorized.",
                  );
                } else {
                  const err = await res.json().catch(() => ({}));
                  console.warn("Failed to reorder cities:", err);
                  showClientError(
                    "Cannot reorder: backend error (read-only mode).",
                  );
                }
              } catch (err) {
                console.warn("Network error reordering cities:", err);
                showClientError(
                  "Cannot reorder: offline or network error (read-only mode).",
                );
              }
            } else {
              trip.cities = newOrder;
              reindexCitySortOrders(trip.cities);
              updateTripInStore();
              render();
            }
          });

          const transportEdit = cityRow.querySelector(".transport-edit");
          const transportModeSel = cityRow.querySelector(".transport-mode");
          const transportNotesInput = cityRow.querySelector(".transport-notes");
          const saveTransportBtn = cityRow.querySelector(
            '[data-action="save-transport"]',
          );
          const removeTransportBtn = cityRow.querySelector(
            '[data-action="remove-transport"]',
          );

          // Click handling to expand/collapse - only on arrow
          const expandArrow = cityRow.querySelector(".expand-arrow");
          expandArrow.addEventListener("click", (e) => {
            e.stopPropagation();

            citiesContainer.querySelectorAll(".city.active").forEach((c) => {
              if (c !== cityRow) c.classList.remove("active");
            });

            cityRow.classList.toggle("active");

            // Resize textarea when city is expanded
            const notesTa = cityRow.querySelector(".city-notes");
            if (notesTa && cityRow.classList.contains("active")) {
              // Use setTimeout to ensure the element is visible before calculating size
              setTimeout(() => {
                autoResizeTextarea(notesTa);
              }, 10);
            }

            // Show transportation editor only for non-last city
            if (transportEdit) {
              const isLast = i === trip.cities.length - 1;
              if (cityRow.classList.contains("active") && !isLast) {
                transportEdit.style.display = "block";
                const nextCity = trip.cities[i + 1];
                const legTransport = nextCity
                  ? findTransportationForLeg(c.id, nextCity.id)
                  : null;
                if (legTransport && transportModeSel && transportNotesInput) {
                  transportModeSel.value = legTransport.mode || "";
                  transportNotesInput.value = legTransport.notes || "";
                } else if (transportModeSel && transportNotesInput) {
                  transportModeSel.value = "";
                  transportNotesInput.value = "";
                }
                const hint = cityRow.querySelector(".transport-hint");
                if (hint && nextCity) {
                  hint.textContent = `Leg: ${c.name || "This city"} â†’ ${
                    nextCity.name || "next city"
                  }`;
                }
              } else {
                transportEdit.style.display = "none";
              }
            }
          });

          const notesTa = cityRow.querySelector(".city-notes");
          const saveNoteBtn = cityRow.querySelector(
            '[data-action="save-note"]',
          );

          if (saveTransportBtn && transportModeSel && transportNotesInput) {
            saveTransportBtn.addEventListener("click", async (ev) => {
              ev.stopPropagation();
              const mode = transportModeSel.value;
              const notesVal = transportNotesInput.value || "";
              const nextCity = trip.cities[i + 1];
              if (!nextCity) return;
              if (!mode) {
                showClientError("Select a transportation mode first.");
                return;
              }

              if (currentUser) {
                try {
                  const token = await getCsrfToken();
                  const res = await fetch(
                    `${API_BASE}/api/trips/${trip.id}/cities/${c.id}/transportation`,
                    {
                      method: "PUT",
                      headers: {
                        "Content-Type": "application/json",
                        "CSRF-Token": token,
                      },
                      credentials: "include",
                      body: JSON.stringify({
                        toCityId: nextCity.id,
                        mode,
                        notes: notesVal,
                      }),
                    },
                  );
                  if (res.ok) {
                    const data = await res.json();
                    const t = data.transportation;
                    upsertTransportationLocal(
                      t.from_city_id,
                      t.to_city_id,
                      t.mode,
                      t.notes || "",
                    );
                  } else if (res.status === 401) {
                    currentUser = null;
                    checkAuth();
                    showClientError("Session expired. Please sign in again.");
                  } else {
                    const err = await res.json().catch(() => ({}));
                    showClientError(
                      err.error || "Failed to save transportation.",
                    );
                  }
                } catch (e) {
                  console.warn("transportation save failed", e);
                  showClientError(
                    "Cannot save transportation: offline or network error.",
                  );
                }
              } else {
                upsertTransportationLocal(c.id, nextCity.id, mode, notesVal);
              }
            });
          }

          if (removeTransportBtn) {
            removeTransportBtn.addEventListener("click", async (ev) => {
              ev.stopPropagation();
              const nextCity = trip.cities[i + 1];
              if (!nextCity) return;

              if (currentUser) {
                try {
                  const token = await getCsrfToken();
                  const res = await fetch(
                    `${API_BASE}/api/trips/${trip.id}/cities/${c.id}/transportation`,
                    {
                      method: "DELETE",
                      headers: {
                        "CSRF-Token": token,
                      },
                      credentials: "include",
                    },
                  );
                  if (res.ok) {
                    removeTransportationLocal(c.id, nextCity.id);
                  } else if (res.status === 401) {
                    currentUser = null;
                    checkAuth();
                    showClientError("Session expired. Please sign in again.");
                  } else {
                    const err = await res.json().catch(() => ({}));
                    showClientError(
                      err.error || "Failed to remove transportation.",
                    );
                  }
                } catch (e) {
                  console.warn("transportation delete failed", e);
                  showClientError(
                    "Cannot remove transportation: offline or network error.",
                  );
                }
              } else {
                removeTransportationLocal(c.id, nextCity.id);
              }
            });
          }

          if (notesTa) {
            // Set initial size (will be resized on expand)

            // Auto-resize on input
            notesTa.addEventListener("input", () => {
              autoResizeTextarea(notesTa);
            });

            // Auto-save on blur: server-first when authenticated
            notesTa.addEventListener("blur", async () => {
              const newNotes = notesTa.value;
              const ok = await updateCity(c.id, { notes: newNotes });
              if (!ok) {
                // Revert textarea value to stored state on failure
                const cc = trip.cities.find(
                  (x) => x.id === c.id || x.id === Number(c.id),
                );
                if (cc) notesTa.value = cc.notes || "";
              }
            });
          }

          if (saveNoteBtn) {
            saveNoteBtn.addEventListener("click", async (ev) => {
              ev.stopPropagation();
              if (notesTa) {
                const newNotes = notesTa.value;
                const ok = await updateCity(c.id, { notes: newNotes });
                if (!ok) {
                  const cc = trip.cities.find(
                    (x) => x.id === c.id || x.id === Number(c.id),
                  );
                  if (cc) notesTa.value = cc.notes || "";
                }
              }
            });
          }

          // Drag and drop
          citiesContainer.appendChild(cityRow);

          // Compact transportation row between this city and the next
          const nextCity = trip.cities[i + 1];
          if (nextCity) {
            const legTransport = findTransportationForLeg(c.id, nextCity.id);
            if (legTransport) {
              const tRow = document.createElement("div");
              tRow.className = "transport-row";
              tRow.style.cssText =
                "display:flex;align-items:center;gap:6px;margin:-2px 0 4px 32px;font-size:13px;color:#555;";

              const modeDef =
                TRANSPORT_MODES.find((m) => m.value === legTransport.mode) ||
                null;
              const icon = modeDef ? modeDef.icon : "";
              const label = modeDef ? modeDef.label : legTransport.mode;

              tRow.innerHTML = `
                <span style="font-size:14px">â†“ ${icon}</span>
                <span>${escapeHtml(label)}</span>
              `;

              citiesContainer.appendChild(tRow);
            }
          }

          dayCursor = end;
        }

        // Add city button
        const bottomAddBtn = document.createElement("div");
        bottomAddBtn.style.textAlign = "center";
        bottomAddBtn.style.marginTop = "12px";
        bottomAddBtn.innerHTML =
          '<button class="btn ghost" style="width:100%">+ Add city</button>';
        bottomAddBtn.querySelector("button").addEventListener("click", (e) => {
          e.stopPropagation();
          createCitySearchPopup(e.target, async (sel) => {
            if (!sel) return;
            const name = (sel.name || "").trim();
            const v = validateCityName(name);
            if (!v.ok) return showClientError(v.error);
            if (trip.cities && trip.cities.length >= MAX_CITIES_PER_TRIP)
              return showClientError(
                `Maximum cities per trip reached (${MAX_CITIES_PER_TRIP}).`,
              );

            // If user is logged in, try to create city in backend first
            if (currentUser) {
              try {
                const token = await getCsrfToken();
                const cityData = {
                  name: name,
                  nights: 1,
                  notes: "",
                };

                // Include coordinates if available
                if (
                  sel.position &&
                  sel.position.latitude &&
                  sel.position.longitude
                ) {
                  cityData.latitude = sel.position.latitude;
                  cityData.longitude = sel.position.longitude;
                }

                const createRes = await fetch(
                  `${API_BASE}/api/trips/${trip.id}/cities`,
                  {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                      "CSRF-Token": token,
                    },
                    credentials: "include",
                    body: JSON.stringify(cityData),
                  },
                );
                if (createRes.status === 201) {
                  const data = await createRes.json();
                  const fallbackOrder = trip.cities.length;
                  // Use backend data to create local city with server-generated ID
                  const newCity = {
                    id: data.id,
                    name: data.name,
                    nights: data.nights,
                    notes: data.notes || "",
                    latitude: data.latitude || null,
                    longitude: data.longitude || null,
                    sort_order: Number.isFinite(Number(data.sort_order))
                      ? Number(data.sort_order)
                      : fallbackOrder,
                    updatedAt: new Date().toISOString(),
                  };
                  trip.cities.push(newCity);
                  reindexCitySortOrders(trip.cities);
                  // Update sort order in backend
                  const updateRes = await fetch(
                    `${API_BASE}/api/trips/${trip.id}/cities`,
                    {
                      method: "PUT",
                      headers: {
                        "Content-Type": "application/json",
                        "CSRF-Token": token,
                      },
                      credentials: "include",
                      body: JSON.stringify({
                        sortOrder: trip.cities.map((c, index) => ({
                          id: c.id,
                          index: index,
                        })),
                      }),
                    },
                  );
                  updateTripInStore();
                  render();
                } else if (createRes.status === 401) {
                  // Session expired
                  console.warn("Session expired");
                  currentUser = null;
                  checkAuth();
                  return showClientError(
                    "Session expired. Please sign in again.",
                  );
                } else if (createRes.status === 400) {
                  // Validation error from backend
                  const err = await createRes.json().catch(() => ({}));
                  console.warn("Validation error creating city:", err);
                  return showClientError(err.error || "Invalid city data.");
                } else if (createRes.status === 404) {
                  // Trip not found or unauthorized
                  const err = await createRes.json().catch(() => ({}));
                  console.warn("Trip not found or unauthorized:", err);
                  return showClientError(
                    err.error ||
                      "Trip not found or you don't have permission to edit it.",
                  );
                } else {
                  // Other backend error - read-only mode
                  const err = await createRes.json().catch(() => ({}));
                  console.warn("Failed to create city in backend:", err);
                  return showClientError(
                    "Cannot add city: backend error (read-only mode).",
                  );
                }
              } catch (e) {
                // Network error or offline - read-only mode
                console.warn(
                  "Failed to create city in backend (network error):",
                  e,
                );
                return showClientError(
                  "Cannot add city: offline or network error (read-only mode).",
                );
              }
            } else {
              // Anonymous user - create locally only
              const newCity = {
                id: uid(),
                name: name,
                nights: 1,
                latitude:
                  sel.position && sel.position.latitude
                    ? sel.position.latitude
                    : null,
                longitude:
                  sel.position && sel.position.longitude
                    ? sel.position.longitude
                    : null,
                sort_order: trip.cities.length,
                updatedAt: new Date().toISOString(),
              };
              trip.cities.push(newCity);
              reindexCitySortOrders(trip.cities);
              updateTripInStore();
              render();
            }
          });
        });
        citiesContainer.appendChild(bottomAddBtn);
      }

      function renderTripCalendar(container) {
        container.innerHTML = '<h3 style="margin:0 0 8px 0">Calendar view</h3>';
        const hint = document.createElement("div");
        hint.className = "small";
        hint.textContent = "Set a trip start date to see the calendar.";
        container.appendChild(hint);
        const months = document.createElement("div");
        months.className = "months";
        container.appendChild(months);

        ensureCitiesSorted(trip);

        if (!trip.start_date || trip.cities.length === 0) {
          hint.style.display = "block";
          return;
        }
        hint.style.display = "none";

        let cur = 1;
        const cityRanges = [];
        for (const c of trip.cities) {
          const s = cur;
          const e = cur + Number(c.nights);
          if (Number(c.nights) > 0) {
            cityRanges.push({
              id: c.id,
              name: c.name || "Unnamed",
              start: s,
              end: e,
            });
          }
          cur = e;
        }

        const tripStart = new Date(trip.start_date);
        const totalDays = cityRanges.length
          ? cityRanges[cityRanges.length - 1].end
          : 0;
        if (totalDays <= 0) return;

        const tripFirstDate = addDays(tripStart, 0);
        const tripLastDate = addDays(tripStart, totalDays - 1);
        const shownMonths = [];
        const m = new Date(
          tripFirstDate.getFullYear(),
          tripFirstDate.getMonth(),
          1,
        );
        while (m <= tripLastDate) {
          shownMonths.push(new Date(m));
          m.setMonth(m.getMonth() + 1);
        }

        const weekdays = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
        for (const monthStart of shownMonths) {
          const monthCard = document.createElement("div");
          monthCard.className = "month-card";
          const monthLabel = monthStart.toLocaleString(undefined, {
            month: "long",
            year: "numeric",
          });
          const header = document.createElement("div");
          header.className = "month-header";
          header.textContent = monthLabel;
          monthCard.appendChild(header);

          const wk = document.createElement("div");
          wk.className = "weekday-row";
          wk.innerHTML = weekdays.map((w) => `<div>${w}</div>`).join("");
          monthCard.appendChild(wk);

          const daysGrid = document.createElement("div");
          daysGrid.className = "days-grid";
          const firstOfMonth = new Date(
            monthStart.getFullYear(),
            monthStart.getMonth(),
            1,
          );
          let weekday = firstOfMonth.getDay();
          let blanks = weekday === 0 ? 6 : weekday - 1;

          for (let i = 0; i < blanks; i++) {
            const b = document.createElement("div");
            b.className = "day blank";
            daysGrid.appendChild(b);
          }

          const daysInMonth = new Date(
            monthStart.getFullYear(),
            monthStart.getMonth() + 1,
            0,
          ).getDate();
          for (let d = 1; d <= daysInMonth; d++) {
            const date = new Date(
              monthStart.getFullYear(),
              monthStart.getMonth(),
              d,
            );
            const msPerDay = 24 * 60 * 60 * 1000;
            const absDay =
              Math.floor(
                (Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()) -
                  Date.UTC(
                    tripStart.getFullYear(),
                    tripStart.getMonth(),
                    tripStart.getDate(),
                  )) /
                  msPerDay,
              ) + 1;
            const dayEl = document.createElement("div");
            dayEl.className = "day";
            dayEl.innerHTML = `<div class="date-num">${d}</div>`;

            if (absDay >= 1 && absDay <= totalDays) {
              const matches = cityRanges.filter(
                (r) => absDay >= r.start && absDay <= r.end,
              );
              if (matches.length) {
                dayEl.classList.add("in-range");
                const topBase = 26;
                const step = 16;
                for (const cr of matches) {
                  const seg = document.createElement("div");
                  seg.className = "range-seg";
                  const idxAll = cityRanges.findIndex((r) => r.id === cr.id);
                  const layer = idxAll % 2;
                  seg.style.top = `${topBase + layer * step}px`;
                  if (absDay === cr.start) seg.classList.add("range-start");
                  if (absDay === cr.end) seg.classList.add("range-end");
                  if (absDay === cr.start) {
                    const segLabel = document.createElement("div");
                    segLabel.className = "seg-label";
                    segLabel.textContent = cr.name;
                    seg.appendChild(segLabel);
                  }
                  dayEl.appendChild(seg);
                }
              }
            } else {
              dayEl.classList.add("blank");
            }
            daysGrid.appendChild(dayEl);
          }
          monthCard.appendChild(daysGrid);
          months.appendChild(monthCard);
        }
      }

      let tripMap = null;

      async function renderTripMap() {
        const mapEl = document.getElementById("tripMap");
        if (!mapEl) return;

        ensureCitiesSorted(trip);

        const MAP_TIMEOUT = 15000; // 15 seconds timeout

        try {
          // Set timeout for the entire map loading process
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(
              () => reject(new Error("Map loading timeout")),
              MAP_TIMEOUT,
            );
          });

          await Promise.race([
            (async () => {
              // Get cities with coordinates
              const citiesWithCoords = [];
              const stepoverCities = []; // Cities with 0 nights

              for (const city of trip.cities) {
                if (!city.name || city.name.trim() === "") continue;

                // Check if city already has coordinates
                if (city.latitude && city.longitude) {
                  const cityData = {
                    id: city.id,
                    name: city.name,
                    nights: Number(city.nights),
                    latitude: Number(city.latitude),
                    longitude: Number(city.longitude),
                  };

                  if (cityData.nights > 0) {
                    citiesWithCoords.push(cityData);
                  } else {
                    stepoverCities.push(cityData);
                  }
                  continue;
                }
              }

              const allCities = [...citiesWithCoords, ...stepoverCities];
              const cityCoordsById = new Map();
              allCities.forEach((city) => {
                if (!cityCoordsById.has(city.id)) {
                  cityCoordsById.set(city.id, city);
                }
              });

              if (allCities.length === 0) {
                mapEl.innerHTML =
                  '<div class="map-error">Add cities to see the route map</div>';
                return;
              }

              // Remove existing map
              if (tripMap) {
                tripMap.remove();
                tripMap = null;
              }

              // Clear loading state
              mapEl.innerHTML = "";

              // Initialize MapLibre GL map
              tripMap = new maplibregl.Map({
                container: "tripMap",
                style:
                  "https://api.tomtom.com/style/2/custom/style/dG9tdG9tQEBAbmNBWHhDa2JUeFJZYXZRUjszvJw2DshKcqFW_sLVVfTP.json?key=" +
                  TOMTOM_API_KEY,
                center: [allCities[0].longitude, allCities[0].latitude],
                zoom: 6,
              });

              // Wait for map to load
              await new Promise((resolve, reject) => {
                tripMap.on("load", resolve);
                tripMap.on("error", reject);
              });

              // Calculate bounds to fit all cities
              if (allCities.length === 1) {
                // For single city, set a reasonable city-level zoom instead of using fitBounds
                const city = allCities[0];
                tripMap.setCenter([city.longitude, city.latitude]);
                tripMap.setZoom(10); // City-level zoom (10-12 is good for city level)
              } else {
                // For multiple cities, use fitBounds as normal
                const bounds = new maplibregl.LngLatBounds();
                allCities.forEach((city) => {
                  bounds.extend([city.longitude, city.latitude]);
                });
                tripMap.fitBounds(bounds, { padding: 50 });
              }

              // Add route line if there are multiple cities
              if (allCities.length > 1) {
                // Create route coordinates including all cities in order
                const routeCoordinates = [];

                for (const city of trip.cities) {
                  if (!city.name || city.name.trim() === "") continue;
                  const cityWithCoords = cityCoordsById.get(city.id);
                  if (cityWithCoords) {
                    routeCoordinates.push([
                      cityWithCoords.longitude,
                      cityWithCoords.latitude,
                    ]);
                  }
                }

                if (routeCoordinates.length > 1) {
                  // Add route line source and layer
                  tripMap.addSource("route", {
                    type: "geojson",
                    data: {
                      type: "Feature",
                      properties: {},
                      geometry: {
                        type: "LineString",
                        coordinates: routeCoordinates,
                      },
                    },
                  });

                  tripMap.addLayer({
                    id: "route-line",
                    type: "line",
                    source: "route",
                    layout: {
                      "line-join": "round",
                      "line-cap": "round",
                    },
                    paint: {
                      "line-color": "#f97316",
                      "line-width": 3,
                      "line-opacity": 0.7,
                    },
                  });
                }
              }

              // Add markers for cities with nights
              citiesWithCoords.forEach((city, index) => {
                const markerEl = document.createElement("div");
                markerEl.className = "city-marker";
                markerEl.textContent = city.nights.toString();

                const marker = new maplibregl.Marker({
                  element: markerEl,
                  anchor: "center",
                })
                  .setLngLat([city.longitude, city.latitude])
                  .addTo(tripMap);

                // Add popup
                const popup = new maplibregl.Popup({ offset: 25 }).setHTML(
                  `<strong>${city.name}</strong><br>${city.nights} night${city.nights !== 1 ? "s" : ""}`,
                );

                marker.setPopup(popup);
              });

              // Add markers for stepover cities (0 nights)
              stepoverCities.forEach((city) => {
                const markerEl = document.createElement("div");
                markerEl.className = "stepover-marker";

                const marker = new maplibregl.Marker({
                  element: markerEl,
                  anchor: "center",
                })
                  .setLngLat([city.longitude, city.latitude])
                  .addTo(tripMap);

                // Add popup
                const popup = new maplibregl.Popup({ offset: 25 }).setHTML(
                  `<strong>${city.name}</strong><br>Stopover`,
                );

                marker.setPopup(popup);
              });
            })(),
            timeoutPromise,
          ]);
        } catch (error) {
          console.error("Failed to render map:", error);
          mapEl.innerHTML =
            '<div class="map-error">Failed to load route map. Please try refreshing later.</div>';
          if (tripMap) {
            tripMap.remove();
            tripMap = null;
          }
        }
      }

      document.addEventListener("click", (e) => {
        if (!e.target.closest(".city")) {
          document
            .querySelectorAll(".city.active")
            .forEach((c) => c.classList.remove("active"));
        }
      });

      render();
      // burger menu toggle (named function)
      function setupBurgerMenu() {
        const burgerBtn = document.getElementById("burgerBtn");
        const burgerMenu = document.getElementById("burgerMenu");
        if (!burgerBtn || !burgerMenu) return;
        // hide burger for anonymous by default
        if (!currentUser) burgerBtn.style.display = "none";

        burgerBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          burgerMenu.style.display =
            burgerMenu.style.display === "none" ? "" : "none";
        });

        // close when clicking outside
        document.addEventListener("click", (e) => {
          if (!e.target.closest("#burgerWrapper")) {
            burgerMenu.style.display = "none";
          }
        });
      }

      setupBurgerMenu();
    </script>

    <footer>
      <div class="footer-links">
        <a href="/">Home</a>
        <a href="/about.html">About</a>
        <a
          href="https://github.com/marcello-dev/trippino"
          target="_blank"
          rel="noopener"
          >GitHub</a
        >
      </div>
      <div>Â© 2025 Trippino. Built with â¤ï¸ for travelers.</div>
    </footer>
  </body>
</html>
